{"version":3,"sources":["stickyheaders.js"],"names":["document","undefined","root","factory","define","amd","exports","module","StickyHeaders","this","el","options","element","stuckHeadersHeight","_updating","_events","_readListStyles","headers","Array","prototype","map","call","querySelectorAll","headerSelector","header","i","clientRect","getBoundingClientRect","clone","cloneNode","classList","add","style","height","headerContainerHeight","dataset","index","top","_listStyles","bind","_createHeaderContainer","_on","onScroll","SCROLL_WIDTH","scrollDiv","createElement","className","body","appendChild","scrollbarWidth","offsetWidth","clientWidth","removeChild","STYLE_TRANSFORM","transforms","length","SCROLL_STEP_DEFAULT","LINE_HEIGHT","borderTopWidth","clientTop","borderLeftWidth","clientLeft","headerWrap","listBorderLeftWidth","left","right","headerContainer","addEventListener","onHeaderActivate","onHeaderScroll","parentNode","insertBefore","ev","target","contains","parseInt","targetHeader","scrollTop","_latestKnownScrollTop","_requestUpdate","setTimeout","updateHeaders","shiftAmount","forEach","isWithinHeaderContainer","requestAnimationFrame","containerOffset","scrollDelta","deltaMode","WheelEvent","DOM_DELTA_PIXEL","deltaY","DOM_DELTA_LINE","preventDefault","event","handler","push","destroy","eventData","removeEventListener","window"],"mappings":"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","file":"stickyheaders.min.js","sourcesContent":[";(function(document, undefined) {\n(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.StickyHeaders = factory();\n  }\n}(this, function() {\n/* global WheelEvent */\n'use strict';\n\nvar SCROLL_WIDTH = (function() {\n    var scrollDiv = document.createElement('div');\n    scrollDiv.className = 'js-scrollbar-measure';\n    document.body.appendChild(scrollDiv);\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n})();\n\nvar STYLE_TRANSFORM = (function getTransitionEndEventName() {\n    var transforms = ['transform', 'webkitTransform'];\n    for (var i = 0; i < transforms.length; i++) {\n        if( document.body.style[transforms[i]] !== undefined ){\n            return transforms[i];\n        }\n    }\n})();\n\nvar SCROLL_STEP_DEFAULT = 50;\nvar LINE_HEIGHT = 16;\n\n/**\n * This plugin enables sticky section headings on a list element.\n *\n * Supported browsers: Chrome, FF, Safari, IE11+\n *\n * @param el - list dom element\n * @param options - an option object. Supports:\n *   - headerSelector - a selector string matching header elements\n */\nfunction StickyHeaders(el, options) {\n    this.element = el;\n    this.options = options;\n    this.stuckHeadersHeight = 0;\n    this._updating = false;\n    this._events = [];\n\n    this._readListStyles();\n\n    // this.headers contains clone elements references and cached dimensions for faster scroll handling\n    this.headers = Array.prototype.map.call(el.querySelectorAll(this.options.headerSelector), function(header, i) {\n        var clientRect = header.getBoundingClientRect();\n\n        var clone = header.cloneNode(true);\n        clone.classList.add('sticky-header', 'is-stuck');\n        // explicitly define the height for the clone, just in case it was applied on the original element\n        // via a selector which is no longer affecting the clone\n        clone.style.height = clientRect.height + 'px';\n        // TODO all clones must be of equal height\n        this.headerContainerHeight = clientRect.height;\n\n        clone.dataset.index = i;\n        return {\n            top: clientRect.top - this._listStyles.top,\n            height: clientRect.height,\n            el: clone\n        };\n    }.bind(this));\n\n    this._createHeaderContainer();\n\n    this._on('scroll', this.onScroll);\n}\n\nStickyHeaders.prototype._readListStyles = function() {\n    var element  = this.element;\n    this._listStyles = {\n        top: element.getBoundingClientRect().top,\n        borderTopWidth: element.clientTop,\n        borderLeftWidth: element.clientLeft\n    };\n\n};\n\nStickyHeaders.prototype._createHeaderContainer = function() {\n    var header = this.header = document.createElement('div');\n    header.className = 'sticky-container';\n\n    var headerWrap = document.createElement('div');\n    var listBorderLeftWidth = this._listStyles.borderLeftWidth;\n    headerWrap.className = 'sticky-container-inner';\n    headerWrap.style.top = this._listStyles.borderTopWidth + 'px';\n    headerWrap.style.left = listBorderLeftWidth + 'px';\n    headerWrap.style.right = (SCROLL_WIDTH + listBorderLeftWidth) + 'px';\n    headerWrap.style.height = this.headerContainerHeight + 'px';\n    header.appendChild(headerWrap);\n\n    var headerContainer = this.headerContainer = document.createElement('div');\n    headerWrap.appendChild(headerContainer);\n\n    header.addEventListener('click', this.onHeaderActivate.bind(this));\n    header.addEventListener('wheel', this.onHeaderScroll.bind(this));\n\n    this.element.parentNode.insertBefore(header, this.element);\n};\n\nStickyHeaders.prototype.onHeaderActivate = function(ev) {\n    if (ev.target.classList.contains('is-stuck')) {\n        var index = parseInt(ev.target.dataset.index, 10);\n        var targetHeader = this.headers[index];\n        this.element.scrollTop = targetHeader.top;\n    }\n};\n\nStickyHeaders.prototype.onScroll = function() {\n    this._latestKnownScrollTop =  this.element.scrollTop;\n    this._requestUpdate();\n};\n\nStickyHeaders.prototype._requestUpdate = function() {\n    if(!this._updating) {\n        setTimeout(this.updateHeaders.bind(this), 0);\n        this._updating = true;\n    }\n};\n\nStickyHeaders.prototype.updateHeaders = function() {\n    var scrollTop = this._latestKnownScrollTop + this._listStyles.borderTopWidth;\n    var shiftAmount = 0;\n\n    this.headers.forEach(function(header) {\n        if (!header.el.parentNode) {\n            if (header.top < scrollTop) {\n                this.headerContainer.appendChild(header.el);\n                this.stuckHeadersHeight += header.height;\n            }\n        } else {\n            if (header.top >= scrollTop) {\n                this.headerContainer.removeChild(header.el);\n                this.stuckHeadersHeight -= header.height;\n            }\n        }\n\n        if (this.isWithinHeaderContainer(header, scrollTop)) {\n            // the distance between the top of the scrollable area and the header top\n            // minus the height of the header container gives the shift amount\n            // for the stuck headers on in order to have an effect of a 'replacement'\n            // of the old header with a new one\n            shiftAmount = (header.top - scrollTop) - this.headerContainerHeight;\n        }\n    }, this);\n\n    shiftAmount += this.headerContainerHeight - this.stuckHeadersHeight;\n\n    requestAnimationFrame(function(containerOffset) {\n        this.headerContainer.style[STYLE_TRANSFORM] = 'translateY(' + containerOffset + 'px)';\n        this._updating = false;\n    }.bind(this, shiftAmount));\n};\n\nStickyHeaders.prototype.onHeaderScroll = function(ev) {\n    var scrollDelta = 0;\n    switch (ev.deltaMode) {\n        case WheelEvent.DOM_DELTA_PIXEL:\n            scrollDelta = ev.deltaY;\n            break;\n        case WheelEvent.DOM_DELTA_LINE:\n            scrollDelta = LINE_HEIGHT * ev.deltaY;\n            break;\n        default:\n            scrollDelta = SCROLL_STEP_DEFAULT;\n    }\n    this.element.scrollTop += scrollDelta;\n    // prevent the viewport from scrolling\n    ev.preventDefault();\n};\n\nStickyHeaders.prototype._on = function(event, handler) {\n    handler = handler.bind(this);\n    this.element.addEventListener(event, handler);\n    this._events.push({\n        el: this.element,\n        ev: event,\n        handler: handler\n    });\n};\n\nStickyHeaders.prototype.destroy = function() {\n    this._events.forEach(function(eventData) {\n        eventData.el.removeEventListener(eventData.ev, eventData.handler);\n    });\n    this.element.parentNode.removeChild(this.header);\n};\n\nStickyHeaders.prototype.isWithinHeaderContainer = function(header, scrollTop) {\n    return header.top >= scrollTop && header.top <= this.headerContainerHeight + scrollTop;\n};\n\nreturn StickyHeaders;\n}));\n})(window.document);"],"sourceRoot":"/source/"}