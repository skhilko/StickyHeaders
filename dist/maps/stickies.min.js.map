{"version":3,"sources":["stickies.js"],"names":["window","document","StickyHeaders","el","options","this","element","stuckHeadersHeight","listOffset","getBoundingClientRect","top","headers","Array","prototype","map","call","querySelectorAll","headerSelector","header","i","clientRect","clone","cloneNode","classList","add","style","height","headerContainerHeight","dataset","index","bottom","bind","_createHeaderContainer","addEventListener","onScroll","SCROLL_WIDTH","scrollDiv","createElement","className","body","appendChild","scrollbarWidth","offsetWidth","clientWidth","removeChild","SCROLL_STEP_DEFAULT","LINE_HEIGHT","headerWrap","right","headerContainer","onHeaderActivate","onHeaderScroll","parentNode","insertBefore","ev","target","contains","parseInt","targetHeader","scrollOffset","scrollTop","shiftAmount","forEach","isWithinHeaderContainer","transform","scrollDelta","deltaMode","WheelEvent","DOM_DELTA_PIXEL","deltaY","DOM_DELTA_LINE","preventDefault"],"mappings":"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","file":"stickies.min.js","sourcesContent":[";(function(window, document, undefined) {/* global WheelEvent */\n'use strict';\n\nvar SCROLL_WIDTH = (function() {\n    var scrollDiv = document.createElement('div');\n    scrollDiv.className = 'js-scrollbar-measure';\n    document.body.appendChild(scrollDiv);\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n})();\n\nvar SCROLL_STEP_DEFAULT = 50;\nvar LINE_HEIGHT = 16;\n\n/**\n * This plugin enables sticky section headings on a list element.\n *\n * Supported browsers: Chrome, FF, Safari, IE11+\n *\n * @param el - list dom element\n * @param options - an option object. Supports:\n *   - headerSelector - a selector string matching header elements\n */\nfunction StickyHeaders(el, options) {\n    this.element = el;\n    this.options = options;\n    this.stuckHeadersHeight = 0;\n\n    var listOffset = el.getBoundingClientRect().top;\n\n    // this.headers contains clone elements references and cached dimensions for faster scroll handling\n    this.headers = Array.prototype.map.call(el.querySelectorAll(this.options.headerSelector), (function(header, i) {\n        var clientRect = header.getBoundingClientRect();\n        var clone = header.cloneNode(true);\n        clone.classList.add('stickies-header', 'is-stuck');\n        // explicitly define the height for the clone, just in case it was applied on the original element\n        // via a selector which is no longer affecting the clone\n        //\n        clone.style.height = clientRect.height + 'px';\n        // TODO all clones must be of equal height\n        this.headerContainerHeight = clientRect.height;\n\n        clone.dataset.index = i;\n        return {\n            top: clientRect.top - listOffset,\n            bottom: clientRect.bottom - listOffset,\n            height: clientRect.height,\n            el: clone\n        };\n    }).bind(this));\n\n    this._createHeaderContainer();\n\n    el.addEventListener('scroll', this.onScroll.bind(this));\n}\n\nStickyHeaders.prototype._createHeaderContainer = function() {\n    var header = document.createElement('div');\n    header.className = 'stickies-container';\n\n    var headerWrap = document.createElement('div');\n    headerWrap.className = 'stickies-container-inner';\n    headerWrap.style.right = SCROLL_WIDTH + 'px';\n    headerWrap.style.height = this.headerContainerHeight + 'px';\n    header.appendChild(headerWrap);\n\n    var headerContainer = this.headerContainer = document.createElement('div');\n    headerWrap.appendChild(headerContainer);\n\n    header.addEventListener('click', this.onHeaderActivate.bind(this));\n    header.addEventListener('wheel', this.onHeaderScroll.bind(this));\n\n    this.element.parentNode.insertBefore(header, this.element);\n};\n\nStickyHeaders.prototype.onHeaderActivate = function(ev) {\n    if (ev.target.classList.contains('is-stuck')) {\n        var index = parseInt(ev.target.dataset.index, 10);\n        var targetHeader = this.headers[index];\n        var scrollOffset = 0;\n        for (var i = 0; i <= index; i++) {\n            scrollOffset += this.headers[i].height;\n        }\n\n        // Scrollable area is reduces by the height of stuck headers.\n        // Need to account for that when jumping to the new position.\n        this.element.scrollTop = targetHeader.bottom - scrollOffset;\n    }\n};\n\nStickyHeaders.prototype.onScroll = function() {\n    var scrollTop = this.element.scrollTop;\n    var shiftAmount = 0;\n\n    this.headers.forEach(function(header) {\n        if (!header.el.parentNode) {\n            if (header.top <= scrollTop) {\n                this.headerContainer.appendChild(header.el);\n                this.stuckHeadersHeight -= header.height;\n            }\n        } else if (header.el.parentNode) {\n            if (header.top >= scrollTop) {\n                this.headerContainer.removeChild(header.el);\n                this.stuckHeadersHeight += header.height;\n            }\n        }\n\n        if (this.isWithinHeaderContainer(header, scrollTop)) {\n            // the distance between the top of the scrollable area and the header top\n            // minus the height of the header container gives the shift amount\n            // for the stuck headers on in order to have an effect of a 'replacement'\n            // of the old header with a new one\n            shiftAmount = (header.top - scrollTop) - this.headerContainerHeight;\n        }\n    }, this);\n\n    shiftAmount += this.stuckHeadersHeight + this.headerContainerHeight;\n\n    this.headerContainer.style.transform = 'translateY(' + shiftAmount + 'px)';\n};\n\nStickyHeaders.prototype.onHeaderScroll = function(ev) {\n    var scrollDelta = 0;\n    switch (ev.deltaMode) {\n        case WheelEvent.DOM_DELTA_PIXEL:\n            scrollDelta = ev.deltaY;\n            break;\n        case WheelEvent.DOM_DELTA_LINE:\n            scrollDelta = LINE_HEIGHT * ev.deltaY;\n            break;\n        default:\n            scrollDelta = SCROLL_STEP_DEFAULT;\n    }\n    this.element.scrollTop += scrollDelta;\n    // prevent the viewport from scrolling\n    ev.preventDefault();\n};\n\nStickyHeaders.prototype.isWithinHeaderContainer = function(header, scrollTop) {\n    return header.top > scrollTop && header.top <= this.headerContainerHeight + scrollTop;\n};\n})(window, window.document);"],"sourceRoot":"/source/"}