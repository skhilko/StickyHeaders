{"version":3,"sources":["main.js","jquery-plugin.js"],"names":["$","window","document","undefined","StickyHeaders","el","options","this","element","stuckHeadersHeight","_updating","_readListStyles","headers","Array","prototype","map","call","querySelectorAll","headerSelector","header","i","clientRect","getBoundingClientRect","clone","cloneNode","classList","add","style","height","headerContainerHeight","dataset","index","top","_listStyles","bind","_createHeaderContainer","addEventListener","onScroll","Plugin","init","SCROLL_WIDTH","scrollDiv","createElement","className","body","appendChild","scrollbarWidth","offsetWidth","clientWidth","removeChild","SCROLL_STEP_DEFAULT","LINE_HEIGHT","borderTopWidth","clientTop","borderLeftWidth","clientLeft","headerWrap","listBorderLeftWidth","left","right","headerContainer","onHeaderActivate","onHeaderScroll","parentNode","insertBefore","ev","target","contains","parseInt","targetHeader","scrollTop","_latestKnownScrollTop","_requestUpdate","setTimeout","updateHeaders","shiftAmount","forEach","isWithinHeaderContainer","requestAnimationFrame","containerOffset","transform","scrollDelta","deltaMode","WheelEvent","DOM_DELTA_PIXEL","deltaY","DOM_DELTA_LINE","preventDefault","pluginName","akno","destroy","removeData","fn","args","arguments","dataKey","each","data","instance","isFunction","apply","slice","jQuery"],"mappings":"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","file":"stickyheaders.jquery.min.js","sourcesContent":["/* global WheelEvent */\n'use strict';\n\nvar SCROLL_WIDTH = (function() {\n    var scrollDiv = document.createElement('div');\n    scrollDiv.className = 'js-scrollbar-measure';\n    document.body.appendChild(scrollDiv);\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n})();\n\nvar SCROLL_STEP_DEFAULT = 50;\nvar LINE_HEIGHT = 16;\n\n/**\n * This plugin enables sticky section headings on a list element.\n *\n * Supported browsers: Chrome, FF, Safari, IE11+\n *\n * @param el - list dom element\n * @param options - an option object. Supports:\n *   - headerSelector - a selector string matching header elements\n */\nfunction StickyHeaders(el, options) {\n    this.element = el;\n    this.options = options;\n    this.stuckHeadersHeight = 0;\n    this._updating = false;\n\n    this._readListStyles();\n\n    // this.headers contains clone elements references and cached dimensions for faster scroll handling\n    this.headers = Array.prototype.map.call(el.querySelectorAll(this.options.headerSelector), function(header, i) {\n        var clientRect = header.getBoundingClientRect();\n\n        var clone = header.cloneNode(true);\n        clone.classList.add('sticky-header', 'is-stuck');\n        // explicitly define the height for the clone, just in case it was applied on the original element\n        // via a selector which is no longer affecting the clone\n        clone.style.height = clientRect.height + 'px';\n        // TODO all clones must be of equal height\n        this.headerContainerHeight = clientRect.height;\n\n        clone.dataset.index = i;\n        return {\n            top: clientRect.top - this._listStyles.top,\n            height: clientRect.height,\n            el: clone\n        };\n    }.bind(this));\n\n    this._createHeaderContainer();\n\n    el.addEventListener('scroll', this.onScroll.bind(this));\n}\n\nStickyHeaders.prototype._readListStyles = function() {\n    var element  = this.element;\n    this._listStyles = {\n        top: element.getBoundingClientRect().top,\n        borderTopWidth: element.clientTop,\n        borderLeftWidth: element.clientLeft\n    };\n\n};\n\nStickyHeaders.prototype._createHeaderContainer = function() {\n    var header = document.createElement('div');\n    header.className = 'sticky-container';\n\n    var headerWrap = document.createElement('div');\n    var listBorderLeftWidth = this._listStyles.borderLeftWidth;\n    headerWrap.className = 'sticky-container-inner';\n    headerWrap.style.top = this._listStyles.borderTopWidth + 'px';\n    headerWrap.style.left = listBorderLeftWidth + 'px';\n    headerWrap.style.right = (SCROLL_WIDTH + listBorderLeftWidth) + 'px';\n    headerWrap.style.height = this.headerContainerHeight + 'px';\n    header.appendChild(headerWrap);\n\n    var headerContainer = this.headerContainer = document.createElement('div');\n    headerWrap.appendChild(headerContainer);\n\n    header.addEventListener('click', this.onHeaderActivate.bind(this));\n    header.addEventListener('wheel', this.onHeaderScroll.bind(this));\n\n    this.element.parentNode.insertBefore(header, this.element);\n};\n\nStickyHeaders.prototype.onHeaderActivate = function(ev) {\n    if (ev.target.classList.contains('is-stuck')) {\n        var index = parseInt(ev.target.dataset.index, 10);\n        var targetHeader = this.headers[index];\n        this.element.scrollTop = targetHeader.top;\n    }\n};\n\nStickyHeaders.prototype.onScroll = function() {\n    this._latestKnownScrollTop =  this.element.scrollTop;\n    this._requestUpdate();\n};\n\nStickyHeaders.prototype._requestUpdate = function() {\n    if(!this._updating) {\n        setTimeout(this.updateHeaders.bind(this), 0);\n        this._updating = true;\n    }\n};\n\nStickyHeaders.prototype.updateHeaders = function() {\n    var scrollTop = this._latestKnownScrollTop + this._listStyles.borderTopWidth;\n    var shiftAmount = 0;\n\n    this.headers.forEach(function(header) {\n        if (!header.el.parentNode) {\n            if (header.top < scrollTop) {\n                this.headerContainer.appendChild(header.el);\n                this.stuckHeadersHeight += header.height;\n            }\n        } else {\n            if (header.top >= scrollTop) {\n                this.headerContainer.removeChild(header.el);\n                this.stuckHeadersHeight -= header.height;\n            }\n        }\n\n        if (this.isWithinHeaderContainer(header, scrollTop)) {\n            // the distance between the top of the scrollable area and the header top\n            // minus the height of the header container gives the shift amount\n            // for the stuck headers on in order to have an effect of a 'replacement'\n            // of the old header with a new one\n            shiftAmount = (header.top - scrollTop) - this.headerContainerHeight;\n        }\n    }, this);\n\n    shiftAmount += this.headerContainerHeight - this.stuckHeadersHeight;\n\n    requestAnimationFrame(function(containerOffset) {\n        this.headerContainer.style.transform = 'translateY(' + containerOffset + 'px)';\n        this._updating = false;\n    }.bind(this, shiftAmount));\n};\n\nStickyHeaders.prototype.onHeaderScroll = function(ev) {\n    var scrollDelta = 0;\n    switch (ev.deltaMode) {\n        case WheelEvent.DOM_DELTA_PIXEL:\n            scrollDelta = ev.deltaY;\n            break;\n        case WheelEvent.DOM_DELTA_LINE:\n            scrollDelta = LINE_HEIGHT * ev.deltaY;\n            break;\n        default:\n            scrollDelta = SCROLL_STEP_DEFAULT;\n    }\n    this.element.scrollTop += scrollDelta;\n    // prevent the viewport from scrolling\n    ev.preventDefault();\n};\n\nStickyHeaders.prototype.isWithinHeaderContainer = function(header, scrollTop) {\n    return header.top >= scrollTop && header.top <= this.headerContainerHeight + scrollTop;\n};\n","var pluginName = 'stickyHeaders';\n\nfunction Plugin(element, options) {\n    this.element = element;\n    this.options = options;\n    this.init();\n}\n\nPlugin.prototype.init = function() {\n    this.akno = new StickyHeaders(this.element, this.options);\n};\n\nPlugin.prototype.destroy = function() {\n    this.akno.destroy();\n    $.removeData(this.element, 'plugin_' + pluginName);\n    this.element = null;\n};\n\n$.fn[pluginName] = function(options) {\n    var args = arguments;\n    var dataKey = 'plugin_' + pluginName;\n    if (options === undefined || typeof options === 'object') {\n        return this.each(function() {\n            if (!$.data(this, dataKey)) {\n                $.data(this, dataKey, new Plugin(this, options));\n            }\n        });\n    } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {\n        return this.each(function() {\n            var instance = $.data(this, dataKey);\n            if (instance instanceof Plugin) {\n                // call with the widget instance if not on the plugin\n                if(!$.isFunction(instance[options]) && $.isFunction(instance.akno[options])) {\n                    instance = instance.akno;\n                }\n                instance[options].apply(instance, Array.prototype.slice.call(args, 1));\n            }\n        });\n    }\n};\n"],"sourceRoot":"/source/"}