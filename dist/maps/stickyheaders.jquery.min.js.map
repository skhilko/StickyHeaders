{"version":3,"sources":["main.js","jquery-plugin.js","stickyheaders.jquery.js"],"names":["$","document","undefined","root","factory","define","amd","exports","module","StickyHeaders","this","el","options","element","stuckHeadersHeight","_updating","_events","_readListStyles","headers","Array","prototype","map","call","querySelectorAll","headerSelector","header","i","clientRect","getBoundingClientRect","clone","cloneNode","classList","add","style","height","headerContainerHeight","dataset","index","top","_listStyles","bind","_createHeaderContainer","_on","onScroll","Plugin","init","SCROLL_WIDTH","scrollDiv","createElement","className","body","appendChild","scrollbarWidth","offsetWidth","clientWidth","removeChild","STYLE_TRANSFORM","transforms","length","SCROLL_STEP_DEFAULT","LINE_HEIGHT","borderTopWidth","clientTop","borderLeftWidth","clientLeft","headerWrap","listBorderLeftWidth","left","right","headerContainer","addEventListener","onHeaderActivate","onHeaderScroll","parentNode","insertBefore","ev","target","contains","parseInt","targetHeader","scrollTop","_latestKnownScrollTop","_requestUpdate","setTimeout","updateHeaders","shiftAmount","forEach","isWithinHeaderContainer","requestAnimationFrame","containerOffset","scrollDelta","deltaMode","WheelEvent","DOM_DELTA_PIXEL","deltaY","DOM_DELTA_LINE","preventDefault","event","handler","push","destroy","eventData","removeEventListener","pluginName","widget","removeData","fn","args","arguments","dataKey","each","data","instance","isFunction","apply","slice","jQuery","window"],"mappings":"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","file":"stickyheaders.jquery.min.js","sourcesContent":["/* global WheelEvent */\n'use strict';\n\nvar SCROLL_WIDTH = (function() {\n    var scrollDiv = document.createElement('div');\n    scrollDiv.className = 'js-scrollbar-measure';\n    document.body.appendChild(scrollDiv);\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n})();\n\nvar STYLE_TRANSFORM = (function getTransitionEndEventName() {\n    var transforms = ['transform', 'webkitTransform'];\n    for (var i = 0; i < transforms.length; i++) {\n        if( document.body.style[transforms[i]] !== undefined ){\n            return transforms[i];\n        }\n    }\n})();\n\nvar SCROLL_STEP_DEFAULT = 50;\nvar LINE_HEIGHT = 16;\n\n/**\n * This plugin enables sticky section headings on a list element.\n *\n * Supported browsers: Chrome, FF, Safari, IE11+\n *\n * @param el - list dom element\n * @param options - an option object. Supports:\n *   - headerSelector - a selector string matching header elements\n */\nfunction StickyHeaders(el, options) {\n    this.element = el;\n    this.options = options;\n    this.stuckHeadersHeight = 0;\n    this._updating = false;\n    this._events = [];\n\n    this._readListStyles();\n\n    // this.headers contains clone elements references and cached dimensions for faster scroll handling\n    this.headers = Array.prototype.map.call(el.querySelectorAll(this.options.headerSelector), function(header, i) {\n        var clientRect = header.getBoundingClientRect();\n\n        var clone = header.cloneNode(true);\n        clone.classList.add('sticky-header', 'is-stuck');\n        // explicitly define the height for the clone, just in case it was applied on the original element\n        // via a selector which is no longer affecting the clone\n        clone.style.height = clientRect.height + 'px';\n        // TODO all clones must be of equal height\n        this.headerContainerHeight = clientRect.height;\n\n        clone.dataset.index = i;\n        return {\n            top: clientRect.top - this._listStyles.top,\n            height: clientRect.height,\n            el: clone\n        };\n    }.bind(this));\n\n    this._createHeaderContainer();\n\n    this._on('scroll', this.onScroll);\n}\n\nStickyHeaders.prototype._readListStyles = function() {\n    var element  = this.element;\n    this._listStyles = {\n        top: element.getBoundingClientRect().top,\n        borderTopWidth: element.clientTop,\n        borderLeftWidth: element.clientLeft\n    };\n\n};\n\nStickyHeaders.prototype._createHeaderContainer = function() {\n    var header = this.header = document.createElement('div');\n    header.className = 'sticky-container';\n\n    var headerWrap = document.createElement('div');\n    var listBorderLeftWidth = this._listStyles.borderLeftWidth;\n    headerWrap.className = 'sticky-container-inner';\n    headerWrap.style.top = this._listStyles.borderTopWidth + 'px';\n    headerWrap.style.left = listBorderLeftWidth + 'px';\n    headerWrap.style.right = (SCROLL_WIDTH + listBorderLeftWidth) + 'px';\n    headerWrap.style.height = this.headerContainerHeight + 'px';\n    header.appendChild(headerWrap);\n\n    var headerContainer = this.headerContainer = document.createElement('div');\n    headerWrap.appendChild(headerContainer);\n\n    header.addEventListener('click', this.onHeaderActivate.bind(this));\n    header.addEventListener('wheel', this.onHeaderScroll.bind(this));\n\n    this.element.parentNode.insertBefore(header, this.element);\n};\n\nStickyHeaders.prototype.onHeaderActivate = function(ev) {\n    if (ev.target.classList.contains('is-stuck')) {\n        var index = parseInt(ev.target.dataset.index, 10);\n        var targetHeader = this.headers[index];\n        this.element.scrollTop = targetHeader.top;\n    }\n};\n\nStickyHeaders.prototype.onScroll = function() {\n    this._latestKnownScrollTop =  this.element.scrollTop;\n    this._requestUpdate();\n};\n\nStickyHeaders.prototype._requestUpdate = function() {\n    if(!this._updating) {\n        setTimeout(this.updateHeaders.bind(this), 0);\n        this._updating = true;\n    }\n};\n\nStickyHeaders.prototype.updateHeaders = function() {\n    var scrollTop = this._latestKnownScrollTop + this._listStyles.borderTopWidth;\n    var shiftAmount = 0;\n\n    this.headers.forEach(function(header) {\n        if (!header.el.parentNode) {\n            if (header.top < scrollTop) {\n                this.headerContainer.appendChild(header.el);\n                this.stuckHeadersHeight += header.height;\n            }\n        } else {\n            if (header.top >= scrollTop) {\n                this.headerContainer.removeChild(header.el);\n                this.stuckHeadersHeight -= header.height;\n            }\n        }\n\n        if (this.isWithinHeaderContainer(header, scrollTop)) {\n            // the distance between the top of the scrollable area and the header top\n            // minus the height of the header container gives the shift amount\n            // for the stuck headers on in order to have an effect of a 'replacement'\n            // of the old header with a new one\n            shiftAmount = (header.top - scrollTop) - this.headerContainerHeight;\n        }\n    }, this);\n\n    shiftAmount += this.headerContainerHeight - this.stuckHeadersHeight;\n\n    requestAnimationFrame(function(containerOffset) {\n        this.headerContainer.style[STYLE_TRANSFORM] = 'translateY(' + containerOffset + 'px)';\n        this._updating = false;\n    }.bind(this, shiftAmount));\n};\n\nStickyHeaders.prototype.onHeaderScroll = function(ev) {\n    var scrollDelta = 0;\n    switch (ev.deltaMode) {\n        case WheelEvent.DOM_DELTA_PIXEL:\n            scrollDelta = ev.deltaY;\n            break;\n        case WheelEvent.DOM_DELTA_LINE:\n            scrollDelta = LINE_HEIGHT * ev.deltaY;\n            break;\n        default:\n            scrollDelta = SCROLL_STEP_DEFAULT;\n    }\n    this.element.scrollTop += scrollDelta;\n    // prevent the viewport from scrolling\n    ev.preventDefault();\n};\n\nStickyHeaders.prototype._on = function(event, handler) {\n    handler = handler.bind(this);\n    this.element.addEventListener(event, handler);\n    this._events.push({\n        el: this.element,\n        ev: event,\n        handler: handler\n    });\n};\n\nStickyHeaders.prototype.destroy = function() {\n    this._events.forEach(function(eventData) {\n        eventData.el.removeEventListener(eventData.ev, eventData.handler);\n    });\n    this.element.parentNode.removeChild(this.header);\n};\n\nStickyHeaders.prototype.isWithinHeaderContainer = function(header, scrollTop) {\n    return header.top >= scrollTop && header.top <= this.headerContainerHeight + scrollTop;\n};\n","var pluginName = 'stickyHeaders';\n\nfunction Plugin(element, options) {\n    this.element = element;\n    this.options = options;\n    this.init();\n}\n\nPlugin.prototype.init = function() {\n    this.widget = new StickyHeaders(this.element, this.options);\n};\n\nPlugin.prototype.destroy = function() {\n    this.widget.destroy();\n    $.removeData(this.element, 'plugin_' + pluginName);\n    this.element = null;\n};\n\n$.fn[pluginName] = function(options) {\n    var args = arguments;\n    var dataKey = 'plugin_' + pluginName;\n    if (options === undefined || typeof options === 'object') {\n        return this.each(function() {\n            if (!$.data(this, dataKey)) {\n                $.data(this, dataKey, new Plugin(this, options));\n            }\n        });\n    } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {\n        return this.each(function() {\n            var instance = $.data(this, dataKey);\n            if (instance instanceof Plugin) {\n                // call with the widget instance if not on the plugin\n                if(!$.isFunction(instance[options]) && $.isFunction(instance.widget[options])) {\n                    instance = instance.widget;\n                }\n                instance[options].apply(instance, Array.prototype.slice.call(args, 1));\n            }\n        });\n    }\n};\n",";(function($, document, undefined) {\n(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.StickyHeaders = factory();\n  }\n}(this, function() {\n/* global WheelEvent */\n'use strict';\n\nvar SCROLL_WIDTH = (function() {\n    var scrollDiv = document.createElement('div');\n    scrollDiv.className = 'js-scrollbar-measure';\n    document.body.appendChild(scrollDiv);\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n})();\n\nvar STYLE_TRANSFORM = (function getTransitionEndEventName() {\n    var transforms = ['transform', 'webkitTransform'];\n    for (var i = 0; i < transforms.length; i++) {\n        if( document.body.style[transforms[i]] !== undefined ){\n            return transforms[i];\n        }\n    }\n})();\n\nvar SCROLL_STEP_DEFAULT = 50;\nvar LINE_HEIGHT = 16;\n\n/**\n * This plugin enables sticky section headings on a list element.\n *\n * Supported browsers: Chrome, FF, Safari, IE11+\n *\n * @param el - list dom element\n * @param options - an option object. Supports:\n *   - headerSelector - a selector string matching header elements\n */\nfunction StickyHeaders(el, options) {\n    this.element = el;\n    this.options = options;\n    this.stuckHeadersHeight = 0;\n    this._updating = false;\n    this._events = [];\n\n    this._readListStyles();\n\n    // this.headers contains clone elements references and cached dimensions for faster scroll handling\n    this.headers = Array.prototype.map.call(el.querySelectorAll(this.options.headerSelector), function(header, i) {\n        var clientRect = header.getBoundingClientRect();\n\n        var clone = header.cloneNode(true);\n        clone.classList.add('sticky-header', 'is-stuck');\n        // explicitly define the height for the clone, just in case it was applied on the original element\n        // via a selector which is no longer affecting the clone\n        clone.style.height = clientRect.height + 'px';\n        // TODO all clones must be of equal height\n        this.headerContainerHeight = clientRect.height;\n\n        clone.dataset.index = i;\n        return {\n            top: clientRect.top - this._listStyles.top,\n            height: clientRect.height,\n            el: clone\n        };\n    }.bind(this));\n\n    this._createHeaderContainer();\n\n    this._on('scroll', this.onScroll);\n}\n\nStickyHeaders.prototype._readListStyles = function() {\n    var element  = this.element;\n    this._listStyles = {\n        top: element.getBoundingClientRect().top,\n        borderTopWidth: element.clientTop,\n        borderLeftWidth: element.clientLeft\n    };\n\n};\n\nStickyHeaders.prototype._createHeaderContainer = function() {\n    var header = this.header = document.createElement('div');\n    header.className = 'sticky-container';\n\n    var headerWrap = document.createElement('div');\n    var listBorderLeftWidth = this._listStyles.borderLeftWidth;\n    headerWrap.className = 'sticky-container-inner';\n    headerWrap.style.top = this._listStyles.borderTopWidth + 'px';\n    headerWrap.style.left = listBorderLeftWidth + 'px';\n    headerWrap.style.right = (SCROLL_WIDTH + listBorderLeftWidth) + 'px';\n    headerWrap.style.height = this.headerContainerHeight + 'px';\n    header.appendChild(headerWrap);\n\n    var headerContainer = this.headerContainer = document.createElement('div');\n    headerWrap.appendChild(headerContainer);\n\n    header.addEventListener('click', this.onHeaderActivate.bind(this));\n    header.addEventListener('wheel', this.onHeaderScroll.bind(this));\n\n    this.element.parentNode.insertBefore(header, this.element);\n};\n\nStickyHeaders.prototype.onHeaderActivate = function(ev) {\n    if (ev.target.classList.contains('is-stuck')) {\n        var index = parseInt(ev.target.dataset.index, 10);\n        var targetHeader = this.headers[index];\n        this.element.scrollTop = targetHeader.top;\n    }\n};\n\nStickyHeaders.prototype.onScroll = function() {\n    this._latestKnownScrollTop =  this.element.scrollTop;\n    this._requestUpdate();\n};\n\nStickyHeaders.prototype._requestUpdate = function() {\n    if(!this._updating) {\n        setTimeout(this.updateHeaders.bind(this), 0);\n        this._updating = true;\n    }\n};\n\nStickyHeaders.prototype.updateHeaders = function() {\n    var scrollTop = this._latestKnownScrollTop + this._listStyles.borderTopWidth;\n    var shiftAmount = 0;\n\n    this.headers.forEach(function(header) {\n        if (!header.el.parentNode) {\n            if (header.top < scrollTop) {\n                this.headerContainer.appendChild(header.el);\n                this.stuckHeadersHeight += header.height;\n            }\n        } else {\n            if (header.top >= scrollTop) {\n                this.headerContainer.removeChild(header.el);\n                this.stuckHeadersHeight -= header.height;\n            }\n        }\n\n        if (this.isWithinHeaderContainer(header, scrollTop)) {\n            // the distance between the top of the scrollable area and the header top\n            // minus the height of the header container gives the shift amount\n            // for the stuck headers on in order to have an effect of a 'replacement'\n            // of the old header with a new one\n            shiftAmount = (header.top - scrollTop) - this.headerContainerHeight;\n        }\n    }, this);\n\n    shiftAmount += this.headerContainerHeight - this.stuckHeadersHeight;\n\n    requestAnimationFrame(function(containerOffset) {\n        this.headerContainer.style[STYLE_TRANSFORM] = 'translateY(' + containerOffset + 'px)';\n        this._updating = false;\n    }.bind(this, shiftAmount));\n};\n\nStickyHeaders.prototype.onHeaderScroll = function(ev) {\n    var scrollDelta = 0;\n    switch (ev.deltaMode) {\n        case WheelEvent.DOM_DELTA_PIXEL:\n            scrollDelta = ev.deltaY;\n            break;\n        case WheelEvent.DOM_DELTA_LINE:\n            scrollDelta = LINE_HEIGHT * ev.deltaY;\n            break;\n        default:\n            scrollDelta = SCROLL_STEP_DEFAULT;\n    }\n    this.element.scrollTop += scrollDelta;\n    // prevent the viewport from scrolling\n    ev.preventDefault();\n};\n\nStickyHeaders.prototype._on = function(event, handler) {\n    handler = handler.bind(this);\n    this.element.addEventListener(event, handler);\n    this._events.push({\n        el: this.element,\n        ev: event,\n        handler: handler\n    });\n};\n\nStickyHeaders.prototype.destroy = function() {\n    this._events.forEach(function(eventData) {\n        eventData.el.removeEventListener(eventData.ev, eventData.handler);\n    });\n    this.element.parentNode.removeChild(this.header);\n};\n\nStickyHeaders.prototype.isWithinHeaderContainer = function(header, scrollTop) {\n    return header.top >= scrollTop && header.top <= this.headerContainerHeight + scrollTop;\n};\n\nvar pluginName = 'stickyHeaders';\n\nfunction Plugin(element, options) {\n    this.element = element;\n    this.options = options;\n    this.init();\n}\n\nPlugin.prototype.init = function() {\n    this.widget = new StickyHeaders(this.element, this.options);\n};\n\nPlugin.prototype.destroy = function() {\n    this.widget.destroy();\n    $.removeData(this.element, 'plugin_' + pluginName);\n    this.element = null;\n};\n\n$.fn[pluginName] = function(options) {\n    var args = arguments;\n    var dataKey = 'plugin_' + pluginName;\n    if (options === undefined || typeof options === 'object') {\n        return this.each(function() {\n            if (!$.data(this, dataKey)) {\n                $.data(this, dataKey, new Plugin(this, options));\n            }\n        });\n    } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {\n        return this.each(function() {\n            var instance = $.data(this, dataKey);\n            if (instance instanceof Plugin) {\n                // call with the widget instance if not on the plugin\n                if(!$.isFunction(instance[options]) && $.isFunction(instance.widget[options])) {\n                    instance = instance.widget;\n                }\n                instance[options].apply(instance, Array.prototype.slice.call(args, 1));\n            }\n        });\n    }\n};\n\nreturn StickyHeaders;\n}));\n})(jQuery, window.document);"],"sourceRoot":"/source/"}