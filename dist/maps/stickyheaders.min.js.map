{"version":3,"sources":["stickyheaders.js"],"names":["window","document","StickyHeaders","el","options","this","element","stuckHeadersHeight","_updating","_readListStyles","headers","Array","prototype","map","call","querySelectorAll","headerSelector","header","i","clientRect","getBoundingClientRect","clone","cloneNode","classList","add","style","height","headerContainerHeight","dataset","index","top","_listStyles","bind","_createHeaderContainer","addEventListener","onScroll","SCROLL_WIDTH","scrollDiv","createElement","className","body","appendChild","scrollbarWidth","offsetWidth","clientWidth","removeChild","SCROLL_STEP_DEFAULT","LINE_HEIGHT","borderTopWidth","clientTop","borderLeftWidth","clientLeft","headerWrap","listBorderLeftWidth","left","right","headerContainer","onHeaderActivate","onHeaderScroll","parentNode","insertBefore","ev","target","contains","parseInt","targetHeader","scrollTop","_latestKnownScrollTop","_requestUpdate","setTimeout","updateHeaders","shiftAmount","forEach","isWithinHeaderContainer","requestAnimationFrame","containerOffset","transform","scrollDelta","deltaMode","WheelEvent","DOM_DELTA_PIXEL","deltaY","DOM_DELTA_LINE","preventDefault"],"mappings":"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","file":"stickyheaders.min.js","sourcesContent":[";(function(window, document, undefined) {/* global WheelEvent */\n'use strict';\n\nvar SCROLL_WIDTH = (function() {\n    var scrollDiv = document.createElement('div');\n    scrollDiv.className = 'js-scrollbar-measure';\n    document.body.appendChild(scrollDiv);\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n})();\n\nvar SCROLL_STEP_DEFAULT = 50;\nvar LINE_HEIGHT = 16;\n\n/**\n * This plugin enables sticky section headings on a list element.\n *\n * Supported browsers: Chrome, FF, Safari, IE11+\n *\n * @param el - list dom element\n * @param options - an option object. Supports:\n *   - headerSelector - a selector string matching header elements\n */\nfunction StickyHeaders(el, options) {\n    this.element = el;\n    this.options = options;\n    this.stuckHeadersHeight = 0;\n    this._updating = false;\n\n    this._readListStyles();\n\n    // this.headers contains clone elements references and cached dimensions for faster scroll handling\n    this.headers = Array.prototype.map.call(el.querySelectorAll(this.options.headerSelector), function(header, i) {\n        var clientRect = header.getBoundingClientRect();\n\n        var clone = header.cloneNode(true);\n        clone.classList.add('sticky-header', 'is-stuck');\n        // explicitly define the height for the clone, just in case it was applied on the original element\n        // via a selector which is no longer affecting the clone\n        clone.style.height = clientRect.height + 'px';\n        // TODO all clones must be of equal height\n        this.headerContainerHeight = clientRect.height;\n\n        clone.dataset.index = i;\n        return {\n            top: clientRect.top - this._listStyles.top,\n            height: clientRect.height,\n            el: clone\n        };\n    }.bind(this));\n\n    this._createHeaderContainer();\n\n    el.addEventListener('scroll', this.onScroll.bind(this));\n}\n\nStickyHeaders.prototype._readListStyles = function() {\n    var element  = this.element;\n    this._listStyles = {\n        top: element.getBoundingClientRect().top,\n        borderTopWidth: element.clientTop,\n        borderLeftWidth: element.clientLeft\n    };\n\n};\n\nStickyHeaders.prototype._createHeaderContainer = function() {\n    var header = document.createElement('div');\n    header.className = 'sticky-container';\n\n    var headerWrap = document.createElement('div');\n    var listBorderLeftWidth = this._listStyles.borderLeftWidth;\n    headerWrap.className = 'sticky-container-inner';\n    headerWrap.style.top = this._listStyles.borderTopWidth + 'px';\n    headerWrap.style.left = listBorderLeftWidth + 'px';\n    headerWrap.style.right = (SCROLL_WIDTH + listBorderLeftWidth) + 'px';\n    headerWrap.style.height = this.headerContainerHeight + 'px';\n    header.appendChild(headerWrap);\n\n    var headerContainer = this.headerContainer = document.createElement('div');\n    headerWrap.appendChild(headerContainer);\n\n    header.addEventListener('click', this.onHeaderActivate.bind(this));\n    header.addEventListener('wheel', this.onHeaderScroll.bind(this));\n\n    this.element.parentNode.insertBefore(header, this.element);\n};\n\nStickyHeaders.prototype.onHeaderActivate = function(ev) {\n    if (ev.target.classList.contains('is-stuck')) {\n        var index = parseInt(ev.target.dataset.index, 10);\n        var targetHeader = this.headers[index];\n        this.element.scrollTop = targetHeader.top;\n    }\n};\n\nStickyHeaders.prototype.onScroll = function() {\n    this._latestKnownScrollTop =  this.element.scrollTop;\n    this._requestUpdate();\n};\n\nStickyHeaders.prototype._requestUpdate = function() {\n    if(!this._updating) {\n        setTimeout(this.updateHeaders.bind(this), 0);\n        this._updating = true;\n    }\n};\n\nStickyHeaders.prototype.updateHeaders = function() {\n    var scrollTop = this._latestKnownScrollTop + this._listStyles.borderTopWidth;\n    var shiftAmount = 0;\n\n    this.headers.forEach(function(header) {\n        if (!header.el.parentNode) {\n            if (header.top < scrollTop) {\n                this.headerContainer.appendChild(header.el);\n                this.stuckHeadersHeight += header.height;\n            }\n        } else {\n            if (header.top >= scrollTop) {\n                this.headerContainer.removeChild(header.el);\n                this.stuckHeadersHeight -= header.height;\n            }\n        }\n\n        if (this.isWithinHeaderContainer(header, scrollTop)) {\n            // the distance between the top of the scrollable area and the header top\n            // minus the height of the header container gives the shift amount\n            // for the stuck headers on in order to have an effect of a 'replacement'\n            // of the old header with a new one\n            shiftAmount = (header.top - scrollTop) - this.headerContainerHeight;\n        }\n    }, this);\n\n    shiftAmount += this.headerContainerHeight - this.stuckHeadersHeight;\n\n    requestAnimationFrame(function(containerOffset) {\n        this.headerContainer.style.transform = 'translateY(' + containerOffset + 'px)';\n        this._updating = false;\n    }.bind(this, shiftAmount));\n};\n\nStickyHeaders.prototype.onHeaderScroll = function(ev) {\n    var scrollDelta = 0;\n    switch (ev.deltaMode) {\n        case WheelEvent.DOM_DELTA_PIXEL:\n            scrollDelta = ev.deltaY;\n            break;\n        case WheelEvent.DOM_DELTA_LINE:\n            scrollDelta = LINE_HEIGHT * ev.deltaY;\n            break;\n        default:\n            scrollDelta = SCROLL_STEP_DEFAULT;\n    }\n    this.element.scrollTop += scrollDelta;\n    // prevent the viewport from scrolling\n    ev.preventDefault();\n};\n\nStickyHeaders.prototype.isWithinHeaderContainer = function(header, scrollTop) {\n    return header.top >= scrollTop && header.top <= this.headerContainerHeight + scrollTop;\n};\n})(window, window.document);"],"sourceRoot":"/source/"}