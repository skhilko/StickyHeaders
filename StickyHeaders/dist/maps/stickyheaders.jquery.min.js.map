{"version":3,"sources":["main.js","jquery-plugin.js"],"names":["$","window","document","undefined","StickyHeaders","el","options","this","element","stuckHeadersHeight","_updating","_readListStyles","headers","Array","prototype","map","call","querySelectorAll","headerSelector","header","i","clientRect","getBoundingClientRect","clone","cloneNode","classList","add","style","height","headerContainerHeight","dataset","index","top","_listStyles","bind","_createHeaderContainer","addEventListener","onScroll","Plugin","init","SCROLL_WIDTH","scrollDiv","createElement","className","body","appendChild","scrollbarWidth","offsetWidth","clientWidth","removeChild","STYLE_TRANSFORM","transforms","length","SCROLL_STEP_DEFAULT","LINE_HEIGHT","borderTopWidth","clientTop","borderLeftWidth","clientLeft","headerWrap","listBorderLeftWidth","left","right","headerContainer","onHeaderActivate","onHeaderScroll","parentNode","insertBefore","ev","target","contains","parseInt","targetHeader","scrollTop","_latestKnownScrollTop","_requestUpdate","setTimeout","updateHeaders","shiftAmount","forEach","isWithinHeaderContainer","requestAnimationFrame","containerOffset","scrollDelta","deltaMode","WheelEvent","DOM_DELTA_PIXEL","deltaY","DOM_DELTA_LINE","preventDefault","pluginName","akno","destroy","removeData","fn","args","arguments","dataKey","each","data","instance","isFunction","apply","slice","jQuery"],"mappings":"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","file":"stickyheaders.jquery.min.js","sourcesContent":["/* global WheelEvent */\n'use strict';\n\nvar SCROLL_WIDTH = (function() {\n    var scrollDiv = document.createElement('div');\n    scrollDiv.className = 'js-scrollbar-measure';\n    document.body.appendChild(scrollDiv);\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n})();\n\nvar STYLE_TRANSFORM = (function getTransitionEndEventName() {\n    var transforms = ['transform', 'webkitTransform'];\n    for (var i = 0; i < transforms.length; i++) {\n        if( document.body.style[transforms[i]] !== undefined ){\n            return transforms[i];\n        }\n    }\n})();\n\nvar SCROLL_STEP_DEFAULT = 50;\nvar LINE_HEIGHT = 16;\n\n/**\n * This plugin enables sticky section headings on a list element.\n *\n * Supported browsers: Chrome, FF, Safari, IE11+\n *\n * @param el - list dom element\n * @param options - an option object. Supports:\n *   - headerSelector - a selector string matching header elements\n */\nfunction StickyHeaders(el, options) {\n    this.element = el;\n    this.options = options;\n    this.stuckHeadersHeight = 0;\n    this._updating = false;\n\n    this._readListStyles();\n\n    // this.headers contains clone elements references and cached dimensions for faster scroll handling\n    this.headers = Array.prototype.map.call(el.querySelectorAll(this.options.headerSelector), function(header, i) {\n        var clientRect = header.getBoundingClientRect();\n\n        var clone = header.cloneNode(true);\n        clone.classList.add('sticky-header', 'is-stuck');\n        // explicitly define the height for the clone, just in case it was applied on the original element\n        // via a selector which is no longer affecting the clone\n        clone.style.height = clientRect.height + 'px';\n        // TODO all clones must be of equal height\n        this.headerContainerHeight = clientRect.height;\n\n        clone.dataset.index = i;\n        return {\n            top: clientRect.top - this._listStyles.top,\n            height: clientRect.height,\n            el: clone\n        };\n    }.bind(this));\n\n    this._createHeaderContainer();\n\n    el.addEventListener('scroll', this.onScroll.bind(this));\n}\n\nStickyHeaders.prototype._readListStyles = function() {\n    var element  = this.element;\n    this._listStyles = {\n        top: element.getBoundingClientRect().top,\n        borderTopWidth: element.clientTop,\n        borderLeftWidth: element.clientLeft\n    };\n\n};\n\nStickyHeaders.prototype._createHeaderContainer = function() {\n    var header = document.createElement('div');\n    header.className = 'sticky-container';\n\n    var headerWrap = document.createElement('div');\n    var listBorderLeftWidth = this._listStyles.borderLeftWidth;\n    headerWrap.className = 'sticky-container-inner';\n    headerWrap.style.top = this._listStyles.borderTopWidth + 'px';\n    headerWrap.style.left = listBorderLeftWidth + 'px';\n    headerWrap.style.right = (SCROLL_WIDTH + listBorderLeftWidth) + 'px';\n    headerWrap.style.height = this.headerContainerHeight + 'px';\n    header.appendChild(headerWrap);\n\n    var headerContainer = this.headerContainer = document.createElement('div');\n    headerWrap.appendChild(headerContainer);\n\n    header.addEventListener('click', this.onHeaderActivate.bind(this));\n    header.addEventListener('wheel', this.onHeaderScroll.bind(this));\n\n    this.element.parentNode.insertBefore(header, this.element);\n};\n\nStickyHeaders.prototype.onHeaderActivate = function(ev) {\n    if (ev.target.classList.contains('is-stuck')) {\n        var index = parseInt(ev.target.dataset.index, 10);\n        var targetHeader = this.headers[index];\n        this.element.scrollTop = targetHeader.top;\n    }\n};\n\nStickyHeaders.prototype.onScroll = function() {\n    this._latestKnownScrollTop =  this.element.scrollTop;\n    this._requestUpdate();\n};\n\nStickyHeaders.prototype._requestUpdate = function() {\n    if(!this._updating) {\n        setTimeout(this.updateHeaders.bind(this), 0);\n        this._updating = true;\n    }\n};\n\nStickyHeaders.prototype.updateHeaders = function() {\n    var scrollTop = this._latestKnownScrollTop + this._listStyles.borderTopWidth;\n    var shiftAmount = 0;\n\n    this.headers.forEach(function(header) {\n        if (!header.el.parentNode) {\n            if (header.top < scrollTop) {\n                this.headerContainer.appendChild(header.el);\n                this.stuckHeadersHeight += header.height;\n            }\n        } else {\n            if (header.top >= scrollTop) {\n                this.headerContainer.removeChild(header.el);\n                this.stuckHeadersHeight -= header.height;\n            }\n        }\n\n        if (this.isWithinHeaderContainer(header, scrollTop)) {\n            // the distance between the top of the scrollable area and the header top\n            // minus the height of the header container gives the shift amount\n            // for the stuck headers on in order to have an effect of a 'replacement'\n            // of the old header with a new one\n            shiftAmount = (header.top - scrollTop) - this.headerContainerHeight;\n        }\n    }, this);\n\n    shiftAmount += this.headerContainerHeight - this.stuckHeadersHeight;\n\n    requestAnimationFrame(function(containerOffset) {\n        this.headerContainer.style[STYLE_TRANSFORM] = 'translateY(' + containerOffset + 'px)';\n        this._updating = false;\n    }.bind(this, shiftAmount));\n};\n\nStickyHeaders.prototype.onHeaderScroll = function(ev) {\n    var scrollDelta = 0;\n    switch (ev.deltaMode) {\n        case WheelEvent.DOM_DELTA_PIXEL:\n            scrollDelta = ev.deltaY;\n            break;\n        case WheelEvent.DOM_DELTA_LINE:\n            scrollDelta = LINE_HEIGHT * ev.deltaY;\n            break;\n        default:\n            scrollDelta = SCROLL_STEP_DEFAULT;\n    }\n    this.element.scrollTop += scrollDelta;\n    // prevent the viewport from scrolling\n    ev.preventDefault();\n};\n\nStickyHeaders.prototype.isWithinHeaderContainer = function(header, scrollTop) {\n    return header.top >= scrollTop && header.top <= this.headerContainerHeight + scrollTop;\n};\n\nwindow.StickyHeaders = StickyHeaders;\n","var pluginName = 'stickyHeaders';\n\nfunction Plugin(element, options) {\n    this.element = element;\n    this.options = options;\n    this.init();\n}\n\nPlugin.prototype.init = function() {\n    this.akno = new StickyHeaders(this.element, this.options);\n};\n\nPlugin.prototype.destroy = function() {\n    this.akno.destroy();\n    $.removeData(this.element, 'plugin_' + pluginName);\n    this.element = null;\n};\n\n$.fn[pluginName] = function(options) {\n    var args = arguments;\n    var dataKey = 'plugin_' + pluginName;\n    if (options === undefined || typeof options === 'object') {\n        return this.each(function() {\n            if (!$.data(this, dataKey)) {\n                $.data(this, dataKey, new Plugin(this, options));\n            }\n        });\n    } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {\n        return this.each(function() {\n            var instance = $.data(this, dataKey);\n            if (instance instanceof Plugin) {\n                // call with the widget instance if not on the plugin\n                if(!$.isFunction(instance[options]) && $.isFunction(instance.akno[options])) {\n                    instance = instance.akno;\n                }\n                instance[options].apply(instance, Array.prototype.slice.call(args, 1));\n            }\n        });\n    }\n};\n"],"sourceRoot":"/source/"}