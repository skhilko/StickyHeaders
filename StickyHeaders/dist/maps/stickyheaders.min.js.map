{"version":3,"sources":["stickyheaders.js"],"names":["window","document","undefined","StickyHeaders","el","options","this","element","stuckHeadersHeight","_updating","_readListStyles","headers","Array","prototype","map","call","querySelectorAll","headerSelector","header","i","clientRect","getBoundingClientRect","clone","cloneNode","classList","add","style","height","headerContainerHeight","dataset","index","top","_listStyles","bind","_createHeaderContainer","addEventListener","onScroll","SCROLL_WIDTH","scrollDiv","createElement","className","body","appendChild","scrollbarWidth","offsetWidth","clientWidth","removeChild","STYLE_TRANSFORM","transforms","length","SCROLL_STEP_DEFAULT","LINE_HEIGHT","borderTopWidth","clientTop","borderLeftWidth","clientLeft","headerWrap","listBorderLeftWidth","left","right","headerContainer","onHeaderActivate","onHeaderScroll","parentNode","insertBefore","ev","target","contains","parseInt","targetHeader","scrollTop","_latestKnownScrollTop","_requestUpdate","setTimeout","updateHeaders","shiftAmount","forEach","isWithinHeaderContainer","requestAnimationFrame","containerOffset","scrollDelta","deltaMode","WheelEvent","DOM_DELTA_PIXEL","deltaY","DOM_DELTA_LINE","preventDefault"],"mappings":"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","file":"stickyheaders.min.js","sourcesContent":[";(function(window, document, undefined) {/* global WheelEvent */\n'use strict';\n\nvar SCROLL_WIDTH = (function() {\n    var scrollDiv = document.createElement('div');\n    scrollDiv.className = 'js-scrollbar-measure';\n    document.body.appendChild(scrollDiv);\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n})();\n\nvar STYLE_TRANSFORM = (function getTransitionEndEventName() {\n    var transforms = ['transform', 'webkitTransform'];\n    for (var i = 0; i < transforms.length; i++) {\n        if( document.body.style[transforms[i]] !== undefined ){\n            return transforms[i];\n        }\n    }\n})();\n\nvar SCROLL_STEP_DEFAULT = 50;\nvar LINE_HEIGHT = 16;\n\n/**\n * This plugin enables sticky section headings on a list element.\n *\n * Supported browsers: Chrome, FF, Safari, IE11+\n *\n * @param el - list dom element\n * @param options - an option object. Supports:\n *   - headerSelector - a selector string matching header elements\n */\nfunction StickyHeaders(el, options) {\n    this.element = el;\n    this.options = options;\n    this.stuckHeadersHeight = 0;\n    this._updating = false;\n\n    this._readListStyles();\n\n    // this.headers contains clone elements references and cached dimensions for faster scroll handling\n    this.headers = Array.prototype.map.call(el.querySelectorAll(this.options.headerSelector), function(header, i) {\n        var clientRect = header.getBoundingClientRect();\n\n        var clone = header.cloneNode(true);\n        clone.classList.add('sticky-header', 'is-stuck');\n        // explicitly define the height for the clone, just in case it was applied on the original element\n        // via a selector which is no longer affecting the clone\n        clone.style.height = clientRect.height + 'px';\n        // TODO all clones must be of equal height\n        this.headerContainerHeight = clientRect.height;\n\n        clone.dataset.index = i;\n        return {\n            top: clientRect.top - this._listStyles.top,\n            height: clientRect.height,\n            el: clone\n        };\n    }.bind(this));\n\n    this._createHeaderContainer();\n\n    el.addEventListener('scroll', this.onScroll.bind(this));\n}\n\nStickyHeaders.prototype._readListStyles = function() {\n    var element  = this.element;\n    this._listStyles = {\n        top: element.getBoundingClientRect().top,\n        borderTopWidth: element.clientTop,\n        borderLeftWidth: element.clientLeft\n    };\n\n};\n\nStickyHeaders.prototype._createHeaderContainer = function() {\n    var header = document.createElement('div');\n    header.className = 'sticky-container';\n\n    var headerWrap = document.createElement('div');\n    var listBorderLeftWidth = this._listStyles.borderLeftWidth;\n    headerWrap.className = 'sticky-container-inner';\n    headerWrap.style.top = this._listStyles.borderTopWidth + 'px';\n    headerWrap.style.left = listBorderLeftWidth + 'px';\n    headerWrap.style.right = (SCROLL_WIDTH + listBorderLeftWidth) + 'px';\n    headerWrap.style.height = this.headerContainerHeight + 'px';\n    header.appendChild(headerWrap);\n\n    var headerContainer = this.headerContainer = document.createElement('div');\n    headerWrap.appendChild(headerContainer);\n\n    header.addEventListener('click', this.onHeaderActivate.bind(this));\n    header.addEventListener('wheel', this.onHeaderScroll.bind(this));\n\n    this.element.parentNode.insertBefore(header, this.element);\n};\n\nStickyHeaders.prototype.onHeaderActivate = function(ev) {\n    if (ev.target.classList.contains('is-stuck')) {\n        var index = parseInt(ev.target.dataset.index, 10);\n        var targetHeader = this.headers[index];\n        this.element.scrollTop = targetHeader.top;\n    }\n};\n\nStickyHeaders.prototype.onScroll = function() {\n    this._latestKnownScrollTop =  this.element.scrollTop;\n    this._requestUpdate();\n};\n\nStickyHeaders.prototype._requestUpdate = function() {\n    if(!this._updating) {\n        setTimeout(this.updateHeaders.bind(this), 0);\n        this._updating = true;\n    }\n};\n\nStickyHeaders.prototype.updateHeaders = function() {\n    var scrollTop = this._latestKnownScrollTop + this._listStyles.borderTopWidth;\n    var shiftAmount = 0;\n\n    this.headers.forEach(function(header) {\n        if (!header.el.parentNode) {\n            if (header.top < scrollTop) {\n                this.headerContainer.appendChild(header.el);\n                this.stuckHeadersHeight += header.height;\n            }\n        } else {\n            if (header.top >= scrollTop) {\n                this.headerContainer.removeChild(header.el);\n                this.stuckHeadersHeight -= header.height;\n            }\n        }\n\n        if (this.isWithinHeaderContainer(header, scrollTop)) {\n            // the distance between the top of the scrollable area and the header top\n            // minus the height of the header container gives the shift amount\n            // for the stuck headers on in order to have an effect of a 'replacement'\n            // of the old header with a new one\n            shiftAmount = (header.top - scrollTop) - this.headerContainerHeight;\n        }\n    }, this);\n\n    shiftAmount += this.headerContainerHeight - this.stuckHeadersHeight;\n\n    requestAnimationFrame(function(containerOffset) {\n        this.headerContainer.style[STYLE_TRANSFORM] = 'translateY(' + containerOffset + 'px)';\n        this._updating = false;\n    }.bind(this, shiftAmount));\n};\n\nStickyHeaders.prototype.onHeaderScroll = function(ev) {\n    var scrollDelta = 0;\n    switch (ev.deltaMode) {\n        case WheelEvent.DOM_DELTA_PIXEL:\n            scrollDelta = ev.deltaY;\n            break;\n        case WheelEvent.DOM_DELTA_LINE:\n            scrollDelta = LINE_HEIGHT * ev.deltaY;\n            break;\n        default:\n            scrollDelta = SCROLL_STEP_DEFAULT;\n    }\n    this.element.scrollTop += scrollDelta;\n    // prevent the viewport from scrolling\n    ev.preventDefault();\n};\n\nStickyHeaders.prototype.isWithinHeaderContainer = function(header, scrollTop) {\n    return header.top >= scrollTop && header.top <= this.headerContainerHeight + scrollTop;\n};\n\nwindow.StickyHeaders = StickyHeaders;\n})(window, window.document);"],"sourceRoot":"/source/"}